From eccb1c3ba0986ea9aa0181a9f931327d4335cc4e Mon Sep 17 00:00:00 2001
From: "Aaron Toderash (adt150)" <aaron.t@usask.ca>
Date: Fri, 14 Jun 2019 14:41:45 -0500
Subject: [PATCH 1/2] WIP: Changing all non-CUDA memory back to stack allocated
 references

---
 src/RPGraphLayout.cpp     |  1 -
 src/RPLayoutAlgorithm.cpp |  2 +-
 src/graph_viewer.cpp      | 13 ++++---------
 3 files changed, 5 insertions(+), 11 deletions(-)

diff --git a/src/RPGraphLayout.cpp b/src/RPGraphLayout.cpp
index 8ca1cfd..e6c9945 100644
--- a/src/RPGraphLayout.cpp
+++ b/src/RPGraphLayout.cpp
@@ -45,7 +45,6 @@ namespace RPGraph
     GraphLayout::GraphLayout(UGraph &graph, float width, float height)
         : graph(graph), width(width), height(height)
     {
-		std::cout << "Layout initializing constructor called" << std::endl;
         // Mem complexity: O(|V|)
         coordinates = (Coordinate *) malloc(graph.num_nodes() * sizeof(Coordinate));
     }
diff --git a/src/RPLayoutAlgorithm.cpp b/src/RPLayoutAlgorithm.cpp
index ed36c00..b06f8ce 100644
--- a/src/RPLayoutAlgorithm.cpp
+++ b/src/RPLayoutAlgorithm.cpp
@@ -31,6 +31,6 @@ namespace RPGraph
     /**
      * An interface for RPForceAtlas2
      */
-    LayoutAlgorithm::LayoutAlgorithm(GraphLayout& layout): layout(layout){ std::cout<<"Layout initializing constructor called"<<std::endl; } /**< TODO: Does this line, particularly `layout(layout) {}` initialize the layout pointer to be a newly constructed layout? YES: This mallocs a new set of coodrinates to be used for the layout algorithm.  Will factor this out. */
+    LayoutAlgorithm::LayoutAlgorithm(GraphLayout& layout): layout(layout){} /**< TODO: Does this line, particularly `layout(layout) {}` initialize the layout pointer to be a newly constructed layout? YES: This mallocs a new set of coodrinates to be used for the layout algorithm.  Will factor this out. */
     LayoutAlgorithm::~LayoutAlgorithm(){}
 }
diff --git a/src/graph_viewer.cpp b/src/graph_viewer.cpp
index f281727..3bc7a60 100644
--- a/src/graph_viewer.cpp
+++ b/src/graph_viewer.cpp
@@ -41,7 +41,6 @@
 #include "RPCPUForceAtlas2.hpp"
 #include "scoda.hpp"
 
-#define __NVCC__ //TODO:  TEMP FOR USE IN VS
 #ifdef __NVCC__
 #include <cuda_runtime_api.h>
 #include "RPGPUForceAtlas2.hpp"
@@ -145,8 +144,8 @@ int main(int argc, const char **argv)
 
     std::fstream edgelist_file(edgelist_path, std::ifstream::in); // TODO: Does this return a reference? Yes. See: https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c and http://www.gotw.ca/gotw/009.htm
 
-    RPGraph::UGraph& full_graph = *(new RPGraph::UGraph()); // indirection: https://stackoverflow.com/questions/44106654/memory-allocation-with-reference-variable-in-c Rethinking this
-    RPGraph::UGraph& comm_graph = *(new RPGraph::UGraph()); // On second thought, upon realizing that the dynamic datastructures within these objects live on the stack anyways, it seems pointless to allocate them dynamically.
+    RPGraph::UGraph& full_graph = RPGraph::UGraph(); // Changed back to stack allocated reference.
+    RPGraph::UGraph& comm_graph = RPGraph::UGraph();
     std::unordered_map<RPGraph::nid_t, RPGraph::nid_t> nid_comm_map; /**< Map is used since node_ids are not necessarily sequentially complete. Stack allocation. */
     // TEMP VALUE!!! TODO::::
     int degree_threshold = 2; // TODO: TEMP VALUE TO TEST COMPILING, should figure out some way to parameterize or detect this in the future.  Note that detection requires streaming the entire graph with the authors implementation.  We could try sampling from the first portion of the graph (say 10%) and using a default value up to that point.
@@ -167,7 +166,7 @@ int main(int argc, const char **argv)
 
     // Create the GraphLayout and ForceAtlas2 objects.
     // TODO: how is this graph allocated? When is it freed?
-    RPGraph::GraphLayout& comm_layout = *(new RPGraph::GraphLayout(comm_graph)); /* Produce initial layout from comm_graph. */ // TODO: Should this be initialized with misdirection as well?
+    RPGraph::GraphLayout& comm_layout = RPGraph::GraphLayout(comm_graph); /* Produce initial layout from comm_graph. */
 	RPGraph::GraphLayout* current_layout = &comm_layout; /* Use pointer in lambdas that can be modified. */
     RPGraph::ForceAtlas2* comm_fa2; // Could be CPU or GPU object.
 	bool randomize = true;
@@ -241,11 +240,9 @@ int main(int argc, const char **argv)
 	fa2 = nullptr;
     // TODO: We are calling delete on a reference, is this valid?
 	delete comm_fa2; /* Free old comm_fa2 object when done.  This is required to deallocate GPU memory. */
-    delete &comm_graph;
-    delete &comm_layout;
 
     // TODO: ERROR: This is the start of our problems according to valgrind.
-    RPGraph::GraphLayout& full_layout = *(new RPGraph::GraphLayout(full_graph)); /* Produce initial layout from comm_graph. */
+    RPGraph::GraphLayout& full_layout = RPGraph::GraphLayout(full_graph);
     current_layout = &full_layout; /* Use pointer in lambdas that can be modified. */
 	// TODO: Use comm_layout to initialize full_layout positions. Must be done before intializing fa2
 	// TODO: THIS DIDN'T WORK. FREE MEMORY PROPERLY LATER. delete fa2; /* Free old fa2 object */
@@ -282,8 +279,6 @@ int main(int argc, const char **argv)
 	fa2 = nullptr;
     // TODO: Create a struct for all these related things, then can have a destructor and just delete it.
 	delete full_fa2; /* Free last ForceAtlas2 object. */
-    delete &full_graph;
-    delete &full_layout;
 
     exit(EXIT_SUCCESS);
 }
-- 
2.19.2.windows.1

From 001c0b5e4fe6f020e15d601e81a83795a7301711 Mon Sep 17 00:00:00 2001
From: "Aaron Toderash (adt150)" <aaron.t@usask.ca>
Date: Fri, 14 Jun 2019 14:51:50 -0500
Subject: [PATCH 2/2] WIP: Refatored initializations

---
 src/graph_viewer.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/graph_viewer.cpp b/src/graph_viewer.cpp
index 3bc7a60..d49cc2b 100644
--- a/src/graph_viewer.cpp
+++ b/src/graph_viewer.cpp
@@ -144,8 +144,8 @@ int main(int argc, const char **argv)
 
     std::fstream edgelist_file(edgelist_path, std::ifstream::in); // TODO: Does this return a reference? Yes. See: https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c and http://www.gotw.ca/gotw/009.htm
 
-    RPGraph::UGraph& full_graph = RPGraph::UGraph(); // Changed back to stack allocated reference.
-    RPGraph::UGraph& comm_graph = RPGraph::UGraph();
+    RPGraph::UGraph full_graph = RPGraph::UGraph(); // Changed back to stack allocated reference.
+    RPGraph::UGraph comm_graph = RPGraph::UGraph();
     std::unordered_map<RPGraph::nid_t, RPGraph::nid_t> nid_comm_map; /**< Map is used since node_ids are not necessarily sequentially complete. Stack allocation. */
     // TEMP VALUE!!! TODO::::
     int degree_threshold = 2; // TODO: TEMP VALUE TO TEST COMPILING, should figure out some way to parameterize or detect this in the future.  Note that detection requires streaming the entire graph with the authors implementation.  We could try sampling from the first portion of the graph (say 10%) and using a default value up to that point.
@@ -166,7 +166,7 @@ int main(int argc, const char **argv)
 
     // Create the GraphLayout and ForceAtlas2 objects.
     // TODO: how is this graph allocated? When is it freed?
-    RPGraph::GraphLayout& comm_layout = RPGraph::GraphLayout(comm_graph); /* Produce initial layout from comm_graph. */
+    RPGraph::GraphLayout comm_layout = RPGraph::GraphLayout(comm_graph); /* Produce initial layout from comm_graph. */
 	RPGraph::GraphLayout* current_layout = &comm_layout; /* Use pointer in lambdas that can be modified. */
     RPGraph::ForceAtlas2* comm_fa2; // Could be CPU or GPU object.
 	bool randomize = true;
@@ -242,7 +242,7 @@ int main(int argc, const char **argv)
 	delete comm_fa2; /* Free old comm_fa2 object when done.  This is required to deallocate GPU memory. */
 
     // TODO: ERROR: This is the start of our problems according to valgrind.
-    RPGraph::GraphLayout& full_layout = RPGraph::GraphLayout(full_graph);
+    RPGraph::GraphLayout full_layout = RPGraph::GraphLayout(full_graph);
     current_layout = &full_layout; /* Use pointer in lambdas that can be modified. */
 	// TODO: Use comm_layout to initialize full_layout positions. Must be done before intializing fa2
 	// TODO: THIS DIDN'T WORK. FREE MEMORY PROPERLY LATER. delete fa2; /* Free old fa2 object */
-- 
2.19.2.windows.1

